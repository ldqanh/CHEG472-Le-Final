# -*- coding: utf-8 -*-
"""Final Exam EDA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1phfsb5fk1v8J-J39tVJBMX-lt3n2lHR7
"""

# Import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import files
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import shap  # For Partial Dependence Plot

#upload the file
uploaded = files.upload()

#load the dataset
file_name = "dataset 4 HTL.xlsx"
df = pd.read_excel(file_name, header = 1)

#display the first few rows
df.head()

# check the data types to identify numeric columns
df.dtypes

df['Biocrude hydrogen content (wt%)'] = pd.to_numeric(df['Biocrude hydrogen content (wt%)'], errors='coerce')
df['Temprature (°C)'] = df['Temprature (°C)'].astype(float)

# check data types again
df.dtypes

# check for missing data
missing_data = df.isnull().sum()

# display columns with missing data
missing_data[missing_data > 0]

# impute missing data with the mean
df['Aqueous phase yield (%)'].fillna(df['Aqueous phase yield (%)'].mean(), inplace=True)
df['Syngas yield (%)'].fillna(df['Syngas yield (%)'].mean(), inplace=True)
df['Hydrochar yield (%)'].fillna(df['Hydrochar yield (%)'].mean(), inplace=True)
df['Biocrude carbon content (wt%)'].fillna(df['Biocrude carbon content (wt%)'].mean(), inplace=True)
df['Biocrude hydrogen content (wt%)'].fillna(df['Biocrude hydrogen content (wt%)'].mean(), inplace=True)
df['Biocrude nitrogen content (wt%)'].fillna(df['Biocrude nitrogen content (wt%)'].mean(), inplace=True)
df['Biocrude oxygen content (wt%)'].fillna(df['Biocrude oxygen content (wt%)'].mean(), inplace=True)
df['Biocrude sulfur content (wt%)'].fillna(df['Biocrude sulfur content (wt%)'].mean(), inplace=True)
df['Biocrude calorific value (MJ/kg)'].fillna(df['Biocrude calorific value (MJ/kg)'].mean(), inplace=True)

# check for missing data
missing_data = df.isnull().sum()

# display columns with missing data
missing_data[missing_data > 0]

# Identify numeric columns
numeric_columns = df.select_dtypes(include=['float']).columns

# Identify categorical columns (assuming they are of type 'object')
categorical_columns = df.select_dtypes(include=['object']).columns

# apply one hot encoded
df_encoded = pd.get_dummies(df, columns=categorical_columns)

df_encoded.head()

# Find duplicate columns
def get_duplicate_columns(df_encoded):
    duplicate_column_names = set()
    for i in range(df_encoded.shape[1]):
        col = df_encoded.iloc[:, i]
        for j in range(i + 1, df_encoded.shape[1]):
            other_col = df_encoded.iloc[:, j]
            if col.equals(other_col):
                duplicate_column_names.add(df_encoded.columns[j])
    return list(duplicate_column_names)
duplicate_columns = get_duplicate_columns(df_encoded) # Pass the DataFrame to the function
print("Duplicate columns:", duplicate_columns)

# Handling the Outliers
# Create the box plot
df.boxplot()
plt.title('Box Plots for Numerical Columns')
plt.xticks(rotation=45)
plt.show()

#Contains ouliers

# Handle outliers
# Calculate the IQR for each numerical column
outlier_threshold = 0.5
q1 = df.select_dtypes(include=np.number).quantile(0.25) # Select numerical columns only
q3 = df.select_dtypes(include=np.number).quantile(0.75) # Select numerical columns only
iqr = q3 - q1
lower_bound = q1 - outlier_threshold * iqr
upper_bound = q3 + outlier_threshold * iqr

# Filter out outliers
df_without_outliers = df[(df[df.select_dtypes(include=np.number).columns] >= lower_bound) & (df[df.select_dtypes(include=np.number).columns] <= upper_bound)]

# Check for the data without outliers
df_without_outliers.boxplot()
plt.title('Box Plots for Numerical Columns (without outliers)')
plt.xticks(rotation=45)
plt.show()

# Outliers are handled by calculating IQR and then removing using lower and upper bound

# Compute correlation matrix for df_without_outliers
corr_matrix_outliers = df_without_outliers.corr()
print(corr_matrix_outliers)

# Correlation Heatmap
plt.figure(figsize=(10, 8))
# Calculate correlation only for numeric columns
numeric_df = df.select_dtypes(include=np.number)  # Select only numeric columns
sns.heatmap(numeric_df.corr(), annot=True, cmap='coolwarm')
plt.title("Correlation Heatmap")
plt.show()

# Plot correlation matrix heatmap for df_without_outliers
plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix_outliers, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix Heatmap for df_without_outliers')
plt.show()